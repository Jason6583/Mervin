/* Generated by re2c 0.13.5 on Tue May 22 00:49:15 2012 */
#include "scan_data.h"

#define YYCTYPE unsigned char;
#define YYFILL(n)  charBuf->fill(instream) 

#define YYGETCONDITION() currentCondition
#define YYSETCONDITION(c) currentCondition = c

struct CharBuf
{
	CharBuf()
	{
		cursor = buffer;
		limit = &buffer[2047];

	}

	fill(istream & instream)
	{  
		int n = limit - cursor;

		if (n < 0)
			n=0;

		if (istream.eof())
		{
			cursor = buffer;
			*cursor = '\0';
		}
		else
		{
			memmove( buffer, cursor, n);
			cursor = buffer + n;			
			// by using get we guarantee that there is a null terminator at eof!
			istream.get(cursor, sizeof(buffer)-n);
		}
	}

	YYCTYPE buffer[2049];
	YYCTYPE * cursor;
	YYCTYPE * limit;
};


void scanData(istream & instream, OnDataReady * onDataReady)
{
	enum YYCONDTYPE {
		yycCMD,
		yycARG,
	} currentCondition;

	CharBuf charBuf;
	int cmdPtr;
	TickDataStruct tickData;

beginning:
	reset();

	
	{
		YYCTYPE yych;
		if (YYGETCONDITION() < 1) {
			goto yyc_CMD;
		} else {
			goto yyc_ARG;
		}
/* *********************************** */
yyc_ARG:

		if ((charBuf->limit - charBuf->cursor) < 2) YYFILL;
		yych = *charBuf->cursor;
		if (yych <= ' ') {
			if (yych <= 0x00) goto yy6;
			if (yych <= 0x1F) goto yy8;
			goto yy4;
		} else {
			if (yych <= '/') goto yy8;
			if (yych >= ':') goto yy8;
		}
		++charBuf->cursor;
		{
				tickData.args.asArray[tickData.nArgs-1] *= 10;
				if (isnegative)
				{
					tickData.args.asArray[tickData.nArgs-1] -= yych - '0';
				}
				else
				{
					tickData.args.asArray[tickData.nArgs-1] += yych - '0';
				}
				goto yyc_ARG;
			}
yy4:
		++charBuf->cursor;
		if ((yych = *charBuf->cursor) == '-') goto yy10;
		if (yych <= '/') goto yy5;
		if (yych <= '9') goto yy12;
yy5:
		{ 
				goto yyc_ARG;
			}
yy6:
		++charBuf->cursor;
		{ 
				return;
			}
yy8:
		++charBuf->cursor;
		{
					signalError(tickData);
					return;
			}
yy10:
		++charBuf->cursor;
		{
				tickData.args.asArray[tickData.nArgs++] = 0;
				isnegative = true;
				goto yyc_ARG;
			}
yy12:
		++charBuf->cursor;
		{ 
				isnegative = false;
				tickData.args.asArray[tickData.nArgs++] = yych - '0';
				goto yyc_ARG;
			}
/* *********************************** */
yyc_CMD:
		if ((charBuf->limit - charBuf->cursor) < 2) YYFILL;
		yych = *charBuf->cursor;
		if (yych <= '/') {
			if (yych <= ' ') {
				if (yych <= 0x00) goto yy18;
				if (yych <= 0x1F) goto yy22;
				goto yy20;
			} else {
				if (yych == '-') goto yy16;
				if (yych <= '.') goto yy22;
			}
		} else {
			if (yych <= '^') {
				if (yych <= '@') goto yy22;
				if (yych >= '[') goto yy22;
			} else {
				if (yych == '`') goto yy22;
				if (yych >= '{') goto yy22;
			}
		}
yy16:
		++charBuf->cursor;
		{ 
						if ( cmdPtr >= MAXCMDLEN ) 
						{
							signalError(tickData);
							return;
						}
						else
						{
							tickData.cmd[cmdPtr++] = yych;
							tickData.cmd[cmdPtr] = '\0';
							goto yyc_CMD;
						}
			}
yy18:
		++charBuf->cursor;
		{return;}
yy20:
		yych = *(YYMARKER = ++charBuf->cursor);
		if (yych <= ',') {
			if (yych == ' ') goto yy25;
		} else {
			if (yych <= '-') goto yy23;
			if (yych <= '/') goto yy21;
			if (yych <= '9') goto yy23;
		}
yy21:
		{
					signalError(tickData);
					return YYCURSOR;
			}
yy22:
		yych = *++charBuf->cursor;
		goto yy21;
yy23:
		++charBuf->cursor;
		{
				    if (cmdPtr > 0)
					{
						if (yych=='-')
						{
							isnegative = true;
							tickData.args.asArray[tickData.nArgs++] = 0;
						}
						else
						{
							isnegative = false; 
							tickData.args.asArray[tickData.nArgs++] = yych - '0';
						}
						YYSETCONDITION(yycARG); 
						goto yyc_ARG;
					}
					goto yyc_CMD;
			}
yy25:
		++charBuf->cursor;
		if (charBuf->limit <= charBuf->cursor) YYFILL;
		yych = *charBuf->cursor;
		if (yych <= ',') {
			if (yych == ' ') goto yy25;
		} else {
			if (yych <= '-') goto yy23;
			if (yych <= '/') goto yy27;
			if (yych <= '9') goto yy23;
		}
yy27:
		charBuf->cursor = YYMARKER;
		goto yy21;
	}

}